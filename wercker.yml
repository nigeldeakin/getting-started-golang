#
# This wercker.yml uses a minimal build
#
dev:
  box:
    id: golang
    ports:
      - "5000"
  steps:
    - internal/watch:
        code: |
          # If we had any dependencies we would need to re-run glide, dep or whatever
          echo "Building...."  
          go build ./...
          ./source
        reload: true

build:
    box: google/golang
    steps:

    # Test the project
    - script:
        name: go test
        code: go test ./...

    # Statically build the project
    - script:
        name: go build
        code: |
          CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o myapp .
          echo Verifying build
          pwd
          ls -l

    # Copy binary to location that gets passed along to deploy (WERCKER_OUTPUT_DIR is /pipeline.output)
    - script:
        name: copy binary
        code: |
          cp myapp "$WERCKER_OUTPUT_DIR"
          echo $WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR

# Push a "normal" (large) image to wcr.io
push-normal-image-to-wcrio:
    box: alpine # does this matter?
    steps:
    - script:
        name: Check what we've got
        code: |
          pwd
          ls -l
          echo WERCKER_GIT_COMMIT=$WERCKER_GIT_COMMIT
          echo WERCKER_ROOT=$WERCKER_ROOT
          echo WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
    - internal/docker-push:
      # Note: The repository parameter can be omitted when the build runs on wercker.com
      tag: wcr-normal
      cmd: $WERCKER_OUTPUT_DIR/myapp
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang   

# This is for local testing
build-and-push:
    box: google/golang
    steps:

    # Test the project
    - script:
        name: go test
        code: go test ./...

    # Statically build the project
    - script:
        name: go build
        code: |
          CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o myapp .
          echo Verifying build
          pwd
          ls -l

    # Copy binary to location that gets passed along to deploy (WERCKER_OUTPUT_DIR is /pipeline.output)
    - script:
        name: copy binary
        code: |
          cp myapp "$WERCKER_OUTPUT_DIR"
    - script:
        name: set environment variables 
        code: |
          DOCKERHUB_USERNAME=nigeldeakin
          DOCKERHUB_PASSWORD=0088Ship
          DOCKERHUB_REPOSITORY=nigeldeakin/getting-started-golang-w-full
    - script:
        # Check what we've got
        name: Check what we've got
        code: |
          ls -l $WERCKER_OUTPUT_DIR
          echo DOCKERHUB_PASSWORD=$DOCKERHUB_PASSWORD
          echo DOCKERHUB_USERNAME=$DOCKERHUB_USERNAME
          echo DOCKERHUB_REPOSITORY=$DOCKERHUB_REPOSITORY
          echo WERCKER_GIT_BRANCH=$WERCKER_GIT_BRANCH
          echo WERCKER_GIT_COMMIT=$WERCKER_GIT_COMMIT
          echo WERCKER_ROOT=$WERCKER_ROOT
          echo WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
    - internal/docker-push:
      # Note: The repository parameter can be omitted
      # if your build runs on wercker.com.
      tag: wcr.io/nigeldeakin/getting-started-golang/$WERCKER_GIT_BRANCH
      cmd: $WERCKER_OUTPUT_DIR/myapp
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang        


