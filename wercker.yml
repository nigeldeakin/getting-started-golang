#
# This wercker.yml uses a minimal build
#
dev:
  box:
    id: golang
    ports:
      - "5000"
  steps:
    - internal/watch:
        code: |
          # If we had any dependencies we would need to re-run glide, dep or whatever
          echo "Building...."  
          go build ./...
          ./source
        reload: true

build:
    box: google/golang
    steps:

    # Test the project
    - script:
        name: go test
        code: go test ./...

    # Statically build the project
    - script:
        name: go build
        code: |
          CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o myapp .
          echo Verifying build
          pwd
          ls -l

    # Copy binary to location that gets passed along to deploy (WERCKER_OUTPUT_DIR is /pipeline.output)
    - script:
        name: copy binary
        code: |
          cp myapp "$WERCKER_OUTPUT_DIR"
          echo $WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR

# This pipeline will be chained to start at the end of a build pipeline in the
# Wercker Web Workflows editor.
push-dockerhub:
    box: alpine # does this matter?
    steps:
    - script:
        # Check what we've got
        name: Check what we've got
        code: |
          pwd
          ls -l
          echo WERCKER_GIT_COMMIT=$WERCKER_GIT_COMMIT
          echo WERCKER_ROOT=$WERCKER_ROOT
          echo WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
    # Create a docker image, and push it to the Docker Hub.
    - internal/docker-push:
        #entrypoint: bin/hello
        cmd: $WERCKER_OUTPUT_DIR/myapp
        working-dir: $WERCKER_ROOT
        tag: $WERCKER_GIT_COMMIT
        ports: "8080"
        username: $DOCKERHUB_USERNAME
        password: $DOCKERHUB_PASSWORD
        repository: $DOCKERHUB_REPOSITORY
        registry: https://registry.hub.docker.com
        

