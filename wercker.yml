#
# This wercker.yml uses a minimal build
#
dev:
  box:
    id: golang
    ports:
      - "5000"
  steps:
    - internal/watch:
        code: |
          # If we had any dependencies we would need to re-run glide, dep or whatever
          echo "Building...."  
          go build ./...
          ./source
        reload: true

build:
    box: google/golang
    steps:

    # Test the project
    - script:
        name: go test
        code: go test ./...

    # Statically build the project
    - script:
        name: go build
        code: |
          CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o myapp .
          echo Verifying build
          pwd
          ls -l

    # Copy binary to location that gets passed along to deploy (WERCKER_OUTPUT_DIR is /pipeline.output)
    - script:
        name: copy binary
        code: |
          cp myapp "$WERCKER_OUTPUT_DIR"
          echo $WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR

# Push a "normal" (large) image to wcr.io
push-normal-image-to-wcrio:
    box: alpine # does this matter?
    steps:
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo $WERCKER_OUTPUT_DIR=WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - internal/docker-push:
      # Note: The repository parameter can be omitted when the build runs on wercker.com
      tag: wcr-normal
      cmd: /pipeline/source/myapp
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang   

    


