dev:
  box:
    id: golang
    ports:
      - "5000"
  steps:
    - internal/watch:
        code: |
          # If we had any dependencies we would need to re-run glide, dep or whatever
          echo "Building...."  
          go build ./...
          ./source
        reload: true

build:
  services:
    - name: fnserver
      id: fnproject/fnserver
  box: google/golang
  steps:
    - script: 
        name: "Wait for Fn connection" 
        code: | 
          echo "About to curl up"
          curl fnserver:8080/metrics
          echo "That was the curl"
          while ! nc -q 1 fnserver 8080 </dev/null; do sleep 3; done


    # Test the project
    - script:
        name: go test
        code: go test ./...

    # Statically build the project
    - script:
        name: go build
        code: |
          CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o myapp .
          echo Verifying build
          pwd
          ls -l
    # Copy binary to location that gets passed along to next pipeline (WERCKER_OUTPUT_DIR is /pipeline/output)
    - script:
        name: copy binary
        code: |
          cp myapp "$WERCKER_OUTPUT_DIR"
          echo $WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - script:
        name: Add sentinels  
        code: |
          touch /pipeline/file-added-to-slash-pipeline
          touch $WERCKER_ROOT/file-added-to-wercker-root
          touch $WERCKER_OUTPUT_DIR/file-added-to-wercker-output_dir        
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - script:
        name: Add more sentinels  
        code: |
          touch /pipeline/file-added-to-slash-pipeline-number-two
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - internal/docker-push: # Creates 220MB image
      tag: wcr-maximal-samepipe
      cmd: /pipeline/source/myapp
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com
    - internal/docker-scratch-push: # Creates 1.43MB image
      tag: wcr-minimal-samepipe
      cmd: /myapp # when creating a minimal image, files in /pipeline/output are copied to / in the new scratch image
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com     
# Push a "maximal" (large) image to wcr.io
push-maximal-image-to-wcrio:
    box: alpine # this seems to also be the used as the base image when we do docker-push, so is actually pretty minimal
    steps:
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - internal/docker-push:
        tag: wcr-newpipe-maximal
        cmd: /pipeline/source/myapp
        ports: "5000"
        repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com
    
# Push a "minimal" (scratch) image to wcr.io
push-minimal-image-to-wcrio:
    box: alpine # I think this is used just to run this pipeline, but the image created using docker-scratch-push uses a "scratch" base image
    steps:
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - internal/docker-scratch-push:
        tag: wcr-newpipe-maximal
        cmd: /pipeline/source/myapp
        ports: "5000"
        repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com
# Start and test the image wcr-maximal-samepipe 
test-wcr-maximal-samepipe:
  services:
    - name: wcr-maximal-samepipe
      id: wcr.io/nigeldeakin/getting-started-golang:wcr-maximal-samepipe
  box: alpine
  steps:
    - script: 
        name: "Wait for wcr-maximal-samepipe connection" 
        code: | 
          echo "About to curl up"
          curl wcr-maximal-samepipe:5000
          echo "That was the curl"
          while ! nc -q 1 wcr-maximal-samepipe 5000 </dev/null; do sleep 3; done
