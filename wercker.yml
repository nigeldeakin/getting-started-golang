dev:
  box:
    id: golang
    ports:
      - "5000"
  steps:
    - internal/watch:
        code: |
          # If we had any dependencies we would need to re-run glide, dep or whatever
          echo "Building...."  
          go build ./...
          ./source
        reload: true

build:
  box: google/golang
  steps:
    # Test the project
    - script:
        name: go test
        code: go test ./...
    # Statically build the project
    - script:
        name: go build
        code: |
          CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o myapp .
          echo Verifying build
          pwd
          ls -l
    # Copy binary to location that gets passed along to next pipeline (WERCKER_OUTPUT_DIR is /pipeline/output)
    - script:
        name: copy binary
        code: |
          cp myapp "$WERCKER_OUTPUT_DIR"
          echo $WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
    - script:
        name: Add sentinels  
        code: |
          touch /pipeline/file-added-to-slash-pipeline
          touch $WERCKER_ROOT/file-added-to-wercker-root
          touch $WERCKER_OUTPUT_DIR/file-added-to-wercker-output_dir        
          touch $WERCKER_CACHE_DIR/file-added-to-wercker-cache_dir        
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
          echo Contents of WERCKER_CACHE_DIR=$WERCKER_CACHE_DIR
          ls -l $WERCKER_CACHE_DIR 
    - internal/store-container           
    - internal/docker-push: # Creates 220MB image
      tag: wcr-maximal-samepipe
      cmd: /pipeline/source/myapp
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com
    - internal/docker-scratch-push: # Creates 1.43MB image
      tag: wcr-minimal-samepipe
      cmd: /myapp # when creating a minimal image, files in /pipeline/output are copied to / in the new scratch image
      ports: "5000"
      repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com     
# Push a "maximal" (large) image to wcr.io
push-maximal-image-to-wcrio:
    box: alpine # this seems to also be the used as the base image when we do docker-push, so is actually pretty minimal
    steps:
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
          echo Contents of WERCKER_CACHE_DIR=$WERCKER_CACHE_DIR
          ls -l $WERCKER_CACHE_DIR     
    - internal/docker-push:
        tag: wcr-newpipe-maximal
        cmd: /pipeline/source/myapp
        ports: "5000"
        repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com
    
# Push a "minimal" (scratch) image to wcr.io
push-minimal-image-to-wcrio:
    box: alpine # I think this is used just to run this pipeline, but the image created using docker-scratch-push uses a "scratch" base image
    steps:
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
          echo Contents of WERCKER_CACHE_DIR=$WERCKER_CACHE_DIR
          ls -l $WERCKER_CACHE_DIR    
    - internal/docker-scratch-push:
        tag: wcr-newpipe-maximal
        cmd: /pipeline/source/myapp
        ports: "5000"
        repository: wcr.io/nigeldeakin/getting-started-golang  # can be omitted when the build runs on wercker.com
# Start and test the image wcr-maximal-samepipe 
test-wcr-maximal-samepipe:
  services:
    - name: wcr-maximal-samepipe
      id: wcr.io/nigeldeakin/getting-started-golang:wcr-maximal-samepipe
  box: odise/busybox-curl
  steps:
    - script: 
        name: "Test image wcr-maximal-samepipe" 
        code: | 
          echo $WERCKER_GIT_COMMIT
          curl wcr-maximal-samepipe:5000 
# This pipeline uses the image created by the previous pipeline
test-using-previous-image:
  box: $WERCKER_LAST_BUILD_BOX
  steps:
    - script:
        name: Dump $WERCKER_LAST_BUILD_BOX
        code: |
          echo WERCKER_LAST_BUILD_BOX=$WERCKER_LAST_BUILD_BOX
    - script:
        name: Check what we've got # looks like pipeline/output ($WERCKER_OUTPUT_DIR) is not copied to next pipeline, but /pipeline/source ($WERCKER_ROOT) is not
        code: |
          echo Contents of /pipeline
          ls -l /pipeline   
          echo Contents of WERCKER_ROOT=$WERCKER_ROOT
          ls -l $WERCKER_ROOT        
          echo Contents of WERCKER_OUTPUT_DIR=$WERCKER_OUTPUT_DIR
          ls -l $WERCKER_OUTPUT_DIR
          echo Contents of WERCKER_CACHE_DIR=$WERCKER_CACHE_DIR
          ls -l $WERCKER_CACHE_DIR       
